= API Levels
:doctype: book
:icons: font
:source-highlighter: highlight.js
:toc: left
:toclevels: 3

include::_attributes.adoc[]

{project-name} is organized as a layered library.
At the bottom sits the immediate-mode API for direct terminal control.
On top of that, TuiRunner adds a managed event loop.
At the highest level, the Toolkit DSL provides a declarative, component-based approach.

You can use any layer directly, or mix them as needed.

[cols="1,2,1",options="header"]
|===
|API |Description |Use When

|<<immediate-mode,Immediate Mode>>
|Direct terminal control - you manage the event loop, drawing, and all state
|Building custom backends, game engines, or learning how things work

|<<tuirunner,TuiRunner>>
|Managed event loop with callbacks for events and rendering
|Custom event handling, animations, widget-based UIs without Toolkit

|<<toolkit-dsl,Toolkit DSL>>
|Declarative, component-based UI with fluent builders
|Most applications - fastest path to a working UI

|<<inline-display-mode,Inline Display>>
|Fixed status area that preserves terminal scroll history
|CLI tools, build progress, package managers
|===

== Immediate Mode

Direct control over the terminal backend, the buffer, and the event loop.
Nothing is hidden - you decide when to poll for events, when to draw, and how to structure your main loop.

=== Terminal and Backend

The `Terminal` wraps a `Backend` that handles the actual terminal I/O:

[source,java]
----
import dev.tamboui.jline.JLineBackend;
import dev.tamboui.terminal.Terminal;

try (var backend = new JLineBackend()) {
    var terminal = new Terminal<>(backend);
    // ...
}
----

Before you can draw anything useful, you need to set up the terminal:

[source,java]
----
// Raw mode disables line buffering - keys are available immediately
backend.enableRawMode();

// Alternate screen preserves the user's terminal content
backend.enterAlternateScreen();

// Hide the cursor for a cleaner look
backend.hideCursor();

// Mouse support is optional
backend.enableMouseCapture();
----

The try-with-resources pattern ensures cleanup happens automatically.
If you're not using it, remember to restore the terminal state before exiting.

=== Drawing

All rendering goes through `terminal.draw()`:

[source,java]
----
terminal.draw(frame -> {
    Rect area = frame.area();  // Full terminal size

    var paragraph = Paragraph.builder()
        .text(Text.from("Hello, TamboUI!"))
        .style(Style.EMPTY.bold().fg(Color.CYAN))
        .build();

    frame.renderWidget(paragraph, area);
});
----

The `Frame` gives you:

- `area()` - the full renderable region
- `buffer()` - direct access to the cell grid
- `renderWidget()` / `renderStatefulWidget()` - render widgets to specific areas

For pixel-level control, work with the buffer directly:

[source,java]
----
terminal.draw(frame -> {
    Buffer buffer = frame.buffer();
    buffer.setCell(0, 0, Cell.of('X', Style.EMPTY.bold()));

    Cell cell = buffer.cell(5, 5);
    // ...
});
----

=== Event Loop

You own the event loop entirely:

[source,java]
----
boolean running = true;

while (running) {
    Event event = backend.pollEvent(Duration.ofMillis(100));

    if (event instanceof KeyEvent key) {
        if (key.code() == KeyCode.CHAR && key.character() == 'q') {
            running = false;
        }
    } else if (event instanceof ResizeEvent) {
        // Terminal resized - might want to redraw
    }

    terminal.draw(frame -> renderUI(frame));
}
----

=== Putting It Together

[source,java]
----
public class ImmediateModeExample {
    public static void main(String[] args) throws Exception {
        try (var backend = new JLineBackend()) {
            backend.enableRawMode();
            backend.enterAlternateScreen();
            backend.hideCursor();

            var terminal = new Terminal<>(backend);
            boolean running = true;

            while (running) {
                Event event = backend.pollEvent(Duration.ofMillis(100));
                if (event instanceof KeyEvent key) {
                    if (key.code() == KeyCode.CHAR && key.character() == 'q') {
                        running = false;
                    }
                }

                terminal.draw(frame -> {
                    var widget = Paragraph.builder()
                        .text(Text.from("Press 'q' to quit"))
                        .style(Style.EMPTY.fg(Color.CYAN))
                        .build();
                    frame.renderWidget(widget, frame.area());
                });
            }
        }
    }
}
----

This is verbose, but you have complete control.
For most applications, you'll want one of the higher-level APIs.

== TuiRunner

TuiRunner takes over terminal setup and the event loop.
You provide two callbacks: one for handling events, one for rendering.

[source,java]
----
try (var tui = TuiRunner.create()) {
    tui.run(
        (event, runner) -> {
            if (event instanceof KeyEvent key && key.isQuit()) {
                runner.quit();
                return false;
            }
            return handleEvent(event);
        },
        frame -> renderUI(frame)
    );
}
----

The event handler returns `true` to request a redraw, `false` otherwise.
This avoids unnecessary redraws when nothing changed.

=== Configuration

[source,java]
----
var config = TuiConfig.builder()
    .mouseCapture(true)
    .tickRate(Duration.ofMillis(16))  // ~60fps for animations
    .pollTimeout(Duration.ofMillis(50))
    .build();

try (var tui = TuiRunner.create(config)) {
    tui.run(handler, renderer);
}
----

Tick events fire at the configured rate - useful for animations, clocks, or any periodic updates.

==== Disabling Ticks

For purely event-driven UIs that only need to refresh on user input, you can disable ticks:

[source,java]
----
var config = TuiConfig.builder()
    .noTick()
    .build();
----

Even with ticks disabled, the UI automatically redraws on terminal resize within the configured grace period (default 250ms).
You can customize this:

[source,java]
----
var config = TuiConfig.builder()
    .noTick()
    .resizeGracePeriod(Duration.ofMillis(100))  // Faster resize response
    .build();
----

Set `resizeGracePeriod(null)` to disable automatic resize handling entirely (not recommended).

=== Error Handling

When exceptions occur during rendering, TuiRunner catches them and displays an error screen with the stack trace.
By default, errors are shown in-app with options to scroll and dismiss:

[source,java]
----
// Default: errors display in UI, press 'q' to quit
try (var tui = TuiRunner.create()) {
    tui.run(handler, renderer);
}
----

Configure error handling behavior via `TuiConfig`:

[source,java]
----
import dev.tamboui.tui.error.RenderErrorHandlers;

// Log errors to a file and quit immediately
var config = TuiConfig.builder()
    .errorHandler(RenderErrorHandlers.logAndQuit(new PrintStream("/tmp/tui-errors.log")))
    .build();

// Write error details to a file, then show in-app error display
var config = TuiConfig.builder()
    .errorHandler(RenderErrorHandlers.writeToFile(Path.of("/tmp/crash.log")))
    .build();
----

Available error handlers:

[cols="1,2",options="header"]
|===
|Handler |Behavior

|`displayAndQuit()` (default)
|Shows full-screen error display with scrollable stack trace, quit on 'q'

|`logAndQuit(PrintStream)`
|Logs error to stream, then exits immediately

|`writeToFile(Path)`
|Writes error to file, then shows in-app display

|`suppress()`
|Logs warning and continues (use with caution)
|===

Custom error handlers implement `RenderErrorHandler`:

[source,java]
----
var config = TuiConfig.builder()
    .errorHandler((error, context) -> {
        // Log error details
        context.errorOutput().println("Error: " + error.message());
        error.cause().printStackTrace(context.errorOutput());
        // Return the action to take
        return ErrorAction.QUIT_IMMEDIATELY;
    })
    .build();
----

=== Semantic Key Checks

`KeyEvent` provides semantic methods that respect the configured bindings:

[source,java]
----
if (key.isQuit()) { }      // q, Q, Ctrl+C
if (key.isUp()) { }        // Up arrow, k, Ctrl+P (with vim bindings)
if (key.isDown()) { }      // Down arrow, j, Ctrl+N
if (key.isSelect()) { }    // Enter, Space
if (key.isCancel()) { }    // Escape
if (key.isPageUp()) { }    // PageUp, Ctrl+B
if (key.isPageDown()) { }  // PageDown, Ctrl+F
----

These delegate to the link:bindings.html[bindings system] - with vim bindings, `isUp()` matches `k`, with standard bindings it only matches the Up arrow.

=== Event Handling Patterns

Pattern matching works well with the event types:

[source,java]
----
(event, runner) -> {
    return switch (event) {
        case KeyEvent k -> handleKey(k);
        case MouseEvent m -> handleMouse(m);
        case TickEvent t -> { animationFrame++; yield true; }
        case ResizeEvent r -> true;  // Always redraw on resize
        default -> false;
    };
}
----

=== Layout in the Renderer

The renderer callback receives a `Frame`, just like immediate mode.
Combine it with the layout system:

[source,java]
----
frame -> {
    var areas = Layout.builder()
        .direction(Direction.VERTICAL)
        .constraints(
            Constraint.length(3),
            Constraint.fill(),
            Constraint.length(1)
        )
        .build()
        .split(frame.area());

    frame.renderWidget(header, areas.get(0));
    frame.renderWidget(content, areas.get(1));
    frame.renderWidget(statusBar, areas.get(2));
}
----

=== Example: Counter with Animation

[source,java]
----
public class CounterDemo {
    private int counter = 0;
    private int ticks = 0;

    public void run() throws Exception {
        var config = TuiConfig.builder()
            .tickRate(Duration.ofMillis(100))
            .build();

        try (var tui = TuiRunner.create(config)) {
            tui.run(this::handleEvent, this::render);
        }
    }

    private boolean handleEvent(Event event, TuiRunner.Runner runner) {
        if (event instanceof KeyEvent key && key.isQuit()) {
            runner.quit();
            return false;
        }
        if (event instanceof TickEvent) {
            ticks++;
            return true;
        }
        if (event instanceof KeyEvent key) {
            if (key.isChar('+')) { counter++; return true; }
            if (key.isChar('-')) { counter--; return true; }
        }
        return false;
    }

    private void render(Frame frame) {
        var text = String.format("Counter: %d (ticks: %d)%n%nPress +/- to change, q to quit",
            counter, ticks);

        var widget = Paragraph.builder()
            .text(Text.from(text))
            .block(Block.builder()
                .title(Text.from("Demo"))
                .borders(Borders.ALL)
                .borderType(BorderType.ROUNDED)
                .build())
            .build();

        frame.renderWidget(widget, frame.area());
    }
}
----

TuiRunner hits a sweet spot: less boilerplate than immediate mode, but you still control the event handling and rendering logic.

== Toolkit DSL

The Toolkit DSL flips the model.
Instead of writing render callbacks, you describe your UI declaratively and let the framework handle the rest.

[source,java]
----
import static dev.tamboui.toolkit.Toolkit.*;
import dev.tamboui.toolkit.app.ToolkitApp;

public class MyApp extends ToolkitApp {

    @Override
    protected Element render() {
        return panel("My App",
            text("Hello!").bold().cyan(),
            spacer(),
            text("Press 'q' to quit").dim()
        ).rounded();
    }

    public static void main(String[] args) throws Exception {
        new MyApp().run();
    }
}
----

The static import `dev.tamboui.toolkit.Toolkit.*` gives you all the element factories: `text()`, `panel()`, `row()`, `column()`, `list()`, `table()`, and more.

=== Layout

Rows and columns work as you'd expect:

[source,java]
----
row(
    panel("Left").fill(),
    panel("Right").fill()
)

column(
    text("Header"),
    content().fill(),
    text("Footer")
)
----

Use `spacer()` to push things apart:

[source,java]
----
row(
    text("Left"),
    spacer(),
    text("Right")
)
----

=== Styling

Style methods chain naturally:

[source,java]
----
text("Styled").bold().italic().cyan().onBlue()
----

Panels support border styling:

[source,java]
----
panel("Title", content)
    .rounded()
    .borderColor(Color.CYAN)
    .focusedBorderColor(Color.YELLOW)
----

=== Sizing

Control how elements fill space:

[source,java]
----
panel("Fixed width").length(30)
panel("Half the space").percentage(50)
panel("Take what's left").fill()
panel("Twice the weight").fill(2)
panel("One third").ratio(1, 3)
panel("At least 10").min(10)
panel("At most 50").max(50)
----

=== Stateful Widgets

Tables and text inputs need state objects. Lists manage their own state internally:

[source,java]
----
private ListElement<?> myList = list("Apple", "Banana", "Cherry")
    .highlightColor(Color.CYAN)
    .autoScroll();

private TableState tableState = new TableState();
private TextInputState inputState = new TextInputState();

// In render():
myList  // ListElement manages selection and scroll internally

table()
    .header("Name", "Age")
    .row("Alice", "30")
    .row("Bob", "25")
    .state(tableState)

textInput(inputState)
    .placeholder("Type here...")
----

ListElement provides methods for navigation:
[source,java]
----
myList.selectNext(itemCount);  // Move selection down
myList.selectPrevious();       // Move selection up
myList.selected();             // Get current selection index
myList.selected(index);        // Set selection to specific index
----

=== Event Handling

Attach handlers to elements:

[source,java]
----
panel("Interactive")
    .id("main")
    .focusable()
    .onKeyEvent(event -> {
        if (event.isChar('a')) {
            addItem();
            return EventResult.HANDLED;
        }
        return EventResult.UNHANDLED;
    })
----

Return `EventResult.HANDLED` to stop propagation, `UNHANDLED` to let it bubble up.

=== Focus

For Tab/Shift+Tab navigation, elements need both an ID and the focusable flag:

[source,java]
----
column(
    panel("First").id("first").focusable(),
    panel("Second").id("second").focusable()
)
----

The `focusedBorderColor()` method lets you provide visual feedback.

=== Data Visualization

[source,java]
----
gauge(0.75).label("Progress").gaugeColor(Color.GREEN)

sparkline(1, 4, 2, 8, 5, 7).color(Color.CYAN)

barChart(10, 20, 30)
    .labels("A", "B", "C")
    .barColor(Color.BLUE)
----

=== Using ToolkitRunner Directly

`ToolkitApp` is convenient, but `ToolkitRunner` gives more control:

[source,java]
----
var config = TuiConfig.builder()
    .mouseCapture(true)
    .tickRate(Duration.ofMillis(50))
    .build();

try (var runner = ToolkitRunner.create(config)) {
    runner.run(() -> panel("App", content()));
}
----

=== Fault-Tolerant Rendering

When enabled, fault-tolerant mode catches exceptions from individual elements and displays error placeholders instead of crashing the entire application.
The rest of the UI continues to render normally.

[source,java]
----
try (var runner = ToolkitRunner.builder()
        .faultTolerant(true)
        .build()) {
    runner.run(() -> render());
}
----

With fault-tolerant mode:

* If an element throws during `render()`, an error placeholder is displayed in its area
* The error placeholder shows a red border with the exception type and message
* Other elements continue to render normally
* Useful for dashboards where one failing widget shouldn't break the entire UI

Without fault-tolerant mode (default):

* Exceptions propagate to `TuiRunner`, which displays a full-screen error
* This is the safer default for most applications

=== Example: Todo List

[source,java]
----
import static dev.tamboui.toolkit.Toolkit.*;

public class TodoApp extends ToolkitApp {
    private final List<String> items = new ArrayList<>(List.of(
        "Learn TamboUI",
        "Build something cool"
    ));
    private final ListElement<?> todoList = list()
        .highlightColor(Color.CYAN)
        .autoScroll();

    @Override
    protected Element render() {
        return panel("Todo",
            items.isEmpty()
                ? text("Empty - press 'a' to add").dim()
                : todoList.items(items.toArray(new String[0])),
            spacer(),
            text("[a]dd [d]elete [q]uit").dim()
        )
        .rounded()
        .id("main")
        .focusable()
        .onKeyEvent(this::handleKey);
    }

    private EventResult handleKey(KeyEvent event) {
        if (event.isChar('a')) {
            items.add("New item");
            return EventResult.HANDLED;
        }
        if (event.isChar('d') && !items.isEmpty()) {
            items.remove(todoList.selected());
            return EventResult.HANDLED;
        }
        if (event.isDown()) {
            todoList.selectNext(items.size());
            return EventResult.HANDLED;
        }
        if (event.isUp()) {
            todoList.selectPrevious();
            return EventResult.HANDLED;
        }
        return EventResult.UNHANDLED;
    }

    public static void main(String[] args) throws Exception {
        new TodoApp().run();
    }
}
----

== Inline Display Mode

The APIs above all use the alternate screen buffer - your application takes over the entire terminal, and the previous content is restored when it exits.

For CLI tools that need to show progress while preserving scroll history, use `InlineDisplay` instead.
This is the pattern used by Gradle, npm, and other build tools: a fixed status area at the bottom while log output scrolls above.

=== When to Use Inline Mode

* Build tools showing compilation progress
* Package managers displaying download status
* Long-running scripts with progress indicators
* Any tool where you want output history preserved

=== Basic Usage

[source,java]
----
try (var display = InlineDisplay.create(3)) {  // Reserve 3 lines
    for (int i = 0; i <= 100; i += 10) {
        display.render((area, buffer) -> {
            var gauge = Gauge.builder()
                .ratio(i / 100.0)
                .label("Processing: " + i + "%")
                .build();
            gauge.render(area, buffer);
        });
        Thread.sleep(100);
    }
}
----

The display reserves lines at the current cursor position.
When closed, it moves the cursor below and optionally clears the status area.

=== Logging Above the Status Area

Use `println()` to add output that scrolls above the fixed status:

[source,java]
----
try (var display = InlineDisplay.create(4)) {
    for (var task : tasks) {
        // Update status area
        display.render((area, buffer) -> {
            renderProgress(area, buffer, task, progress);
        });

        processTask(task);

        // Log completion - scrolls above, status stays fixed
        display.println(Text.from(Line.from(
            Span.styled("âœ“ ", Style.EMPTY.fg(Color.GREEN)),
            Span.raw(task.name())
        )));
    }
}
----

=== Configuration Options

[source,java]
----
// Fixed height (width matches terminal)
var display = InlineDisplay.create(4);

// Fixed height and width
var display = InlineDisplay.create(4, 80);

// Clear the status area when done
var display = InlineDisplay.create(4).clearOnClose();
----

=== Setting Lines Directly

For simple status updates, set lines without a full render:

[source,java]
----
display.setLine(0, "Building module: core");
display.setLine(1, "Progress: 45%");
display.setLine(2, Text.from(Span.styled("No errors", Style.EMPTY.fg(Color.GREEN))));
----

=== Inline vs Alternate Screen

[cols="1,2,2",options="header"]
|===
|Feature |InlineDisplay |TuiRunner / Toolkit

|Screen buffer
|Main buffer (preserved)
|Alternate buffer (replaced)

|Cursor
|Visible
|Hidden

|Terminal capture
|Partial (reserved lines)
|Full terminal

|Previous content
|Preserved above
|Restored on exit

|Best for
|Progress, logs, status
|Interactive full-screen apps
|===

== Choosing a Level

**Start with the Toolkit DSL** for most applications.
It handles focus, provides a clean declarative API, and gets you productive quickly.

**Drop to TuiRunner** when you need custom event handling, animations, or want to use the widget layer directly without the Toolkit abstractions.

**Use Immediate Mode** when you're building something unusual - a custom backend, a game engine, or when you want to understand exactly what's happening under the hood.

The levels compose well.
You can use Toolkit elements inside a TuiRunner application, or drop down to direct buffer manipulation when needed.

== Next Steps

* link:styling.html[CSS Styling] - external stylesheets and theming
* link:bindings.html[Bindings and Actions] - key bindings and action handling
* link:mvc-architecture.html[Application Structure] - patterns for larger applications
* link:widgets.html[Widgets Reference] - all available widgets
* link:developer-guide.html[Developer Guide] - building custom widgets
